# Documentation & Website Plan

> Planning document for the `openapi-mocks` public website and documentation.

---

## Tech Stack

| Concern | Tool |
|---|---|
| Framework | [Astro](https://astro.build/) with [Starlight](https://starlight.astro.build/) |
| API Reference | [TypeDoc](https://typedoc.org/) via [`starlight-typedoc`](https://github.com/HiDeoo/starlight-typedoc) |
| Hosting | [Cloudflare Pages](https://pages.cloudflare.com/) |
| Markdown Rendering | Cloudflare `Accept` header conversion + custom `.md` route handling |

### Why Starlight

Starlight is Astro's first-party documentation theme. It provides sidebar navigation, search, versioning support, dark mode, and i18n out of the box — all as an Astro integration with zero client-side JS by default. This avoids building doc-site chrome from scratch and keeps the focus on content.

### Why TypeDoc + starlight-typedoc

TypeDoc is the de facto standard for generating API reference documentation from TypeScript source. It reads JSDoc/TSDoc comments and type signatures directly — no separate schema to maintain. The `starlight-typedoc` plugin bridges the two by generating Starlight-compatible Markdown pages from TypeDoc output at build time, so API reference pages live alongside hand-written docs in a single unified site with consistent navigation and styling.

**Alternatives considered:**

- **api-extractor + api-documenter** (Microsoft) — more opinionated, heavier setup, designed for monorepos. Overkill for a single-package library.
- **Fumadocs / Nextra** — React-based (Next.js). Pulls in a client runtime we don't need and doesn't align with the Astro choice.

---

## Hosting & Deployment

### Cloudflare Pages

The site deploys to Cloudflare Pages from the docs directory of the monorepo (or a dedicated `docs/` repo — TBD).

**Build configuration:**

- **Build command:** `astro build`
- **Output directory:** `dist/`
- **Node version:** ≥ 20

### Markdown Content Negotiation

Cloudflare Pages supports content negotiation via the `Accept` header. When a client sends `Accept: text/markdown`, Cloudflare can return the Markdown source of the page instead of the rendered HTML. This is useful for programmatic consumers (LLMs, CLI tools, scrapers) that prefer raw Markdown.

In addition to the `Accept` header mechanism, the site should support appending `.md` to any documentation URL to retrieve the Markdown version in the browser. This is implemented as a Cloudflare Pages Function (or an Astro server endpoint if using hybrid rendering) that:

1. Strips the `.md` suffix from the URL.
2. Resolves the corresponding Markdown source file.
3. Returns it with `Content-Type: text/markdown; charset=utf-8`.

Every documentation page includes a visible **"View as Markdown"** link (in the page header or footer) that points to the `.md` variant of the current URL. This makes the feature discoverable without requiring users to know about `Accept` headers.

**Implementation notes:**

- Starlight pages are authored as `.md` or `.mdx` files in `src/content/docs/`. The `.md` route handler reads from this source directory.
- API reference pages generated by `starlight-typedoc` are also emitted as Markdown — the same handler covers them.
- The `Accept` header path is handled automatically by Cloudflare and requires no custom code beyond enabling the feature.

---

## Monorepo Layout

The docs site and examples live alongside the library source in a single monorepo:

```
/
├── packages/
│   └── openapi-mocks/       → Library source
├── docs/                     → Astro/Starlight site
│   ├── src/content/docs/     → Hand-written documentation
│   ├── astro.config.mjs
│   └── package.json
├── examples/
│   ├── playwright/           → Playwright E2E example
│   ├── mock-server/          → Standalone mock server example
│   └── ...
└── package.json              → Workspace root
```

Each directory under `examples/` is an independent sub-package with its own `package.json`. Consumers can clone the monorepo, `cd` into any example, install, and run it without needing the rest of the workspace. This makes examples easy to reference from the docs (relative links to source) while still being self-contained enough to serve as starter templates.

The `docs/` directory holds the Astro site. Because it lives in the same repo as the library source, `starlight-typedoc` can point directly at the package's entry points for API reference generation — no publish step or separate type artifact needed.

```
/                           → Home / Quick Start
/examples/                  → Examples index
/examples/playwright/       → Playwright E2E testing
/examples/mock-server/      → Standalone mock server (no MSW)
/examples/storybook/        → Storybook integration (future)
/guides/                    → Guides index
/guides/configuration/      → Global & per-operation options
/guides/composition/        → oneOf / anyOf / allOf handling
/guides/faker-extensions/   → x-faker-method usage
/guides/smart-defaults/     → Smart default mapping reference
/guides/zod-integration/    → Zod validation via openapi-mocks/zod (TBD)
/reference/                 → API Reference (auto-generated by TypeDoc)
/reference/generate-mock-data/
/reference/generate-msw-handlers/
/reference/generate-from-schema/
```

---

## Page Content

### Home / Quick Start (`/`)

The landing page serves as both introduction and quick start. It should get a reader from zero to working mock handlers in under two minutes.

**Sections:**

1. **Hero** — one-line description: _"Generate realistic mock data and MSW handlers from your OpenAPI spec."_
2. **Installation** — tabbed code blocks for npm / pnpm / yarn / bun. Include peer dependency instructions for MSW and Zod subpath exports.
3. **Use cases** — short prose (not a bullet list) covering the three primary scenarios:
   - Unit / integration tests that need realistic API responses without a running backend.
   - Storybook stories wired to mock data so components render with representative content.
   - Local development with a mock server that returns spec-compliant responses while the real API is unavailable or unstable.
4. **Minimal code example** — two blocks side by side (or stacked):
   - **Mock data only:** `generateMockData` with a small inline spec, showing the output.
   - **MSW handlers:** `generateMSWHandlers` wired into `setupServer`, showing a test file that makes a fetch and asserts on the response.
5. **Next steps** — links to the examples and guides sections.

### Examples

Each example is a self-contained walkthrough backed by a runnable sub-package in the monorepo's `examples/` directory. Readers can clone the repo, `cd` into the relevant example, and run it directly.

#### Playwright E2E Tests (`/examples/playwright/`)

Demonstrates using `generateMSWHandlers` output to intercept network requests inside Playwright tests.

**Content:**

- Brief explanation of the problem: E2E tests that depend on a live API are slow and flaky.
- Project setup: Playwright config, MSW browser integration (`setupWorker`), and the OpenAPI spec file.
- Generating handlers from the spec with `generateMSWHandlers`.
- Wiring handlers into Playwright's `page.addInitScript` or a service worker approach.
- A complete test file that navigates to a page, asserts rendered content matches the mock data, and demonstrates per-test overrides (e.g., forcing an error response for one endpoint).
- Notes on seeding for deterministic snapshots.

#### Standalone Mock Server (`/examples/mock-server/`)

Demonstrates using the core `generateMockData` function (without MSW) to build a lightweight Express/Hono server that serves mock responses.

**Content:**

- Use case: a frontend team needs a running HTTP server that returns realistic data while the backend team is still building the real API. MSW isn't appropriate here because there's no browser or test runner — it's a standalone process.
- Project setup: a minimal Node server (Express or Hono), the OpenAPI spec, and `openapi-mocks` as a dependency.
- Iterating over the spec's paths and operations, calling `generateMockData` for each response schema, and registering corresponding routes on the server.
- Handling path parameters (using `echoPathParams` or manual extraction).
- Running the server and hitting it with `curl`.
- Notes on limitations vs. a real mock server (no statefulness, no request validation).

### Guides

#### Configuration (`/guides/configuration/`)

Reference-style page covering every global and per-operation option. For each option: type signature, default value, description, and a short code example showing the option in use. This page complements the auto-generated API reference by providing narrative context.

#### Composition (`/guides/composition/`)

Explains how the library handles `allOf`, `oneOf`, and `anyOf`, including discriminator support. Includes schema snippets and the corresponding generated output. Calls out behavioral differences between OpenAPI 3.0.x and 3.1.x (e.g., `nullable` vs. `type: ["string", "null"]`).

#### Faker Extensions (`/guides/faker-extensions/`)

How to use `x-faker-method` to map schema properties to specific Faker methods. Includes a table of example dot-paths (`internet.email`, `image.avatar`, `lorem.paragraphs`, etc.) and a walkthrough of adding the extension to an existing spec.

#### Smart Defaults (`/guides/smart-defaults/`)

The full curated mapping table (property name → Faker method) so consumers know what's handled automatically and can decide when they need `x-faker-method` instead.

#### Zod Integration (`/guides/zod-integration/`)

> **Status: TBD** — the exact shape of the Zod integration is still being scoped (see open questions in the project overview). This page should be stubbed early and fleshed out once the API solidifies.

Covers the `openapi-mocks/zod` subpath export. At minimum, this page should explain:

- What the Zod subpath provides and when you'd reach for it (e.g., validating that generated mock data conforms to a consumer-maintained Zod schema, catching drift between an OpenAPI spec and application-level types).
- Installation — Zod as a peer dependency, importing from `openapi-mocks/zod`.
- A usage example, even if minimal, showing the Zod utilities wired into a test or build step.
- How it relates to the core library — the Zod subpath is purely additive and the core `generateMockData` / `generateMSWHandlers` functions work without it.

### API Reference (`/reference/`)

Auto-generated by `starlight-typedoc` from the library's public exports. Covers:

- `generateMockData` — parameters, return type, options interface.
- `generateMSWHandlers` — parameters, return type, options interface, handler shape.
- `generateFromSchema` — parameters, return type, options interface.
- All public TypeScript interfaces and types (options objects, result shapes, etc.).

No hand-written content here — the source of truth is the TSDoc comments in the codebase. The plugin generates pages at build time and slots them into Starlight's sidebar.

---

## Markdown Discoverability

Every page rendered by Starlight includes a **"View as Markdown"** link. This is implemented as a Starlight component override (or a custom Astro component injected via Starlight's `components` config) that renders a small link in the page header area:

```
View as Markdown →  /current/path.md
```

The link points to the current page's URL with `.md` appended. Clicking it in a browser returns the raw Markdown source. This is also noted once in the site footer or an "About this site" page so users understand the convention applies globally.

---

## Open Questions

- **Doc deploy cadence:** Docs live in the monorepo (simplifies TypeDoc reading source directly), but doc deploys are coupled to library releases. Consider a Cloudflare Pages build filter or a separate deploy trigger if this becomes a friction point.
- **Versioning:** Does the site need version switching for docs (e.g., v1 vs. v2)? Starlight supports this but it adds maintenance overhead. Likely unnecessary until v2 ships.
- **Search:** Starlight includes Pagefind for static search out of the box. Confirm this works well on Cloudflare Pages (it should — it's a static build artifact).
